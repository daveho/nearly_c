# NearlyC: a front-end for a substantial subset of C

This is a lexer and parser for a substantial subset of C.

C features that are missing:

* Typedefs
* Arrays
* Pointers
* Variadic functions
* Abstract declarators (e.g., omitting a parameter name from a function declaration)

There are probably other things that are missing or don't work.

I will probably add arrays and pointers at some point.

There are also some restrictions. For example, a storage class specifier
(`static` or `extern`) must precede the type in a declaration or definition,
so code like

```
int static x;
```

isn't allowed.

## Why?

My intention is to use this as the source language in a project sequence
in the compilers course I teach.

Full modern C (e.g., ISO C, C99, C11, etc.) has surprising complexity.
However, with some careful omission of difficult language features, such
as typedefs, we get what I think is a core language that is powerful,
but not too difficult to understand.

## Some technical details

The lexer is implemented with Flex and the parser is implemented with Bison.

The parser is a "pure" parser, and the lexer is reentrant (and uses `%option bison-bridge`),
so no global variables are needed.

All code is C++.  Note that neither the lexer nor parser is generated as a C++
class: the "plain" code generated by both Flex and Bison compiles fine as C++.
My personal opinion is that the C++ code generation in both Flex and Bison
is confusion and has no real advantage over the standard pure parser and reentrant
scanner code generation.

A ruby script, [scan\_grammar\_symbols.rb](scan_grammar_symbols.rb),
is used to extract the names of all terminal and nonterminal symbols from
the grammar, so that they can be used to enumerate and stringify all
symbol names. This script assumes that every nonterminal symbol

* appears on a line by itself, not indented, and
* consists only of lower-case letters and underscores

## Parse trees vs. ASTs

THere are actually two parsers, [parse.y](parse.y) and [parse\_buildast.y](parse_buildast.y).
The former builds a full parse tree, while the latter builds an AST
(abstract syntax tree.)  I plan to keep them in sync with each other.
The former is useful for validating the parser itself, and is probably
the better option for source to source translation, while the latter
is probably much more useful as a compiler front-end.

You can choose which parser to use by editing the [Makefile](Makefile).

## Compiling the program

Run the commands

```
make depend
make
```

## Running the program

Run the command as

```
./nearly_c -p input.c
```

(The `-p` option means "print a tree".)

Consider this code:

```c
int sum(int a, int b) {
  return a + b;
}
```

This input generates the parse tree (using [parse.y](parse.y))

```
Skiddly bob
```

This input generates the AST (using [parse\_buildast.y](parse_buildast.y))
